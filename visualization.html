<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MineDrone 3Då¯è§†åŒ–ç•Œé¢</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e1e, #2d2d2d);
            color: white;
            overflow: hidden;
        }

        .main-container {
            display: grid;
            grid-template-columns: 350px 1fr;
            grid-template-rows: 1fr;
            height: 100vh;
            gap: 1px;
        }

        /* å·¦ä¾§æ§åˆ¶é¢æ¿ */
        .control-panel {
            background: linear-gradient(180deg, #2a2a2a, #1e1e1e);
            border-right: 2px solid #4CAF50;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 4px 0 20px rgba(0,0,0,0.3);
        }

        /* å³ä¾§è§†å›¾åŒºåŸŸ */
        .views-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 2px;
            background: #1a1a1a;
            padding: 2px;
        }

        /* è§†å›¾åŒºåŸŸæ ·å¼ */
        .view-area {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            border: 2px solid transparent;
            background: #000;
            transition: border-color 0.3s ease;
        }

        .view-area:hover {
            border-color: #4CAF50;
        }

        .view-area.active {
            border-color: #FFD700;
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.3);
        }

        .view-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(76, 175, 80, 0.9), rgba(76, 175, 80, 0.7));
            padding: 8px 15px;
            font-weight: bold;
            font-size: 14px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .view-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .view-icon {
            font-size: 16px;
        }

        .view-controls {
            display: flex;
            gap: 5px;
        }

        .control-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .view-content {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* 1åŒºåŸŸ - MineflyerVieweræ¸¸æˆç”»é¢ */
        .viewer-area {
            grid-column: 1;
            grid-row: 1 / 3;
        }

        .viewer-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: #222;
        }

        /* 2åŒºåŸŸ - 2Dè§†é‡ */
        .mini-map-area {
            grid-column: 2;
            grid-row: 1;
        }

        .mini-map-canvas {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
        }

        /* 3åŒºåŸŸ - 3Dç©ºé—´å»ºæ¨¡ */
        .modeling-area {
            grid-column: 2;
            grid-row: 2;
        }

        /* æ§åˆ¶é¢æ¿å…ƒç´ æ ·å¼ */
        .panel-section {
            background: linear-gradient(145deg, #3a3a3a, #2d2d2d);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(76, 175, 80, 0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .panel-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #4CAF50;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 8px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f44336;
            animation: pulse 2s infinite;
            margin-right: 8px;
        }

        .status-indicator.connected {
            background: #4CAF50;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
        }

        .info-item {
            background: rgba(255,255,255,0.05);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            border-left: 3px solid #4CAF50;
        }

        .info-label {
            font-size: 11px;
            opacity: 0.8;
            margin-bottom: 4px;
        }

        .info-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #FFD700;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
        }

        .btn {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.danger {
            background: linear-gradient(145deg, #f44336, #d32f2f);
            box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
        }

        .btn.danger:hover {
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
        }

        .input-group {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }

        .coord-input {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(76, 175, 80, 0.5);
            color: white;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        .coord-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
        }

        .stats-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-card {
            background: linear-gradient(145deg, #4a4a4a, #3d3d3d);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border-top: 3px solid #FFD700;
        }

        .stat-number {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
            display: block;
        }

        .stat-label {
            font-size: 10px;
            opacity: 0.8;
        }

        .blocks-list {
            max-height: 120px;
            overflow-y: auto;
            background: #1a1a1a;
            border-radius: 8px;
            padding: 8px;
        }

        .block-type {
            background: rgba(76, 175, 80, 0.1);
            margin: 3px 0;
            padding: 6px 8px;
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
        }

        .log-panel {
            max-height: 100px;
            overflow-y: auto;
            background: #1a1a1a;
            border-radius: 8px;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .log-entry:nth-child(odd) {
            background: rgba(255,255,255,0.02);
        }

        /* è§†å›¾ç‰¹å®šæ ·å¼ */
        .view-settings {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 6px;
            font-size: 10px;
            z-index: 200;
        }

        .setting-item {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 3px 0;
        }

        .setting-item input[type="checkbox"] {
            width: 12px;
            height: 12px;
        }

        .setting-item input[type="range"] {
            width: 60px;
            height: 16px;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 300px 1fr;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            
            .control-panel {
                max-height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <!-- è¿æ¥çŠ¶æ€ -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>ğŸ”—</span> è¿æ¥çŠ¶æ€
                </div>
                <div style="display: flex; align-items: center;">
                    <div class="status-indicator" id="connection-indicator"></div>
                    <span id="connection-text">æ­£åœ¨è¿æ¥...</span>
                </div>
            </div>

            <!-- AgentçŠ¶æ€ -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>ğŸ¤–</span> AgentçŠ¶æ€
                </div>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">ä½ç½® X</div>
                        <div class="info-value" id="pos-x">0.00</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">ä½ç½® Y</div>
                        <div class="info-value" id="pos-y">0.00</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">ä½ç½® Z</div>
                        <div class="info-value" id="pos-z">0.00</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">æœå‘</div>
                        <div class="info-value" id="pos-yaw">0.00Â°</div>
                    </div>
                </div>
                <div class="info-item" style="grid-column: 1 / -1; margin-top: 8px;">
                    <div class="info-label">çŠ¶æ€</div>
                    <div class="info-value" id="nav-status">å¾…æœº</div>
                </div>
            </div>

            <!-- å¯¼èˆªæ§åˆ¶ -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>ğŸ®</span> å¯¼èˆªæ§åˆ¶
                </div>
                <div class="input-group" style="gap:2px;">
                    <input type="number" class="coord-input" id="nav-x" placeholder="X" step="0.1" style="width:60px;">
                    <input type="number" class="coord-input" id="nav-y" placeholder="Y" step="0.1" style="width:60px;">
                    <input type="number" class="coord-input" id="nav-z" placeholder="Z" step="0.1" style="width:60px;">
                </div>
                <div class="control-buttons">
                    <button class="btn" onclick="navigateTo()">ğŸš€ å¯¼èˆª</button>
                    <button class="btn danger" onclick="stopNavigation()">â›” åœæ­¢</button>
                    <button class="btn" onclick="getCurrentPos()">ğŸ“ å½“å‰</button>
                    <button class="btn" onclick="getStatus()">ğŸ”„ åˆ·æ–°</button>
                </div>
            </div>

            <!-- ç›®æ ‡ä¿¡æ¯ -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>ğŸ¯</span> ç›®æ ‡ä¿¡æ¯
                </div>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">ç›®æ ‡ X</div>
                        <div class="info-value" id="target-x">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">ç›®æ ‡ Y</div>
                        <div class="info-value" id="target-y">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">ç›®æ ‡ Z</div>
                        <div class="info-value" id="target-z">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">è·ç¦»</div>
                        <div class="info-value" id="target-distance">-- m</div>
                    </div>
                </div>
            </div>

            <!-- è®°å¿†ç»Ÿè®¡ -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>ğŸ“Š</span> è®°å¿†ç»Ÿè®¡
                </div>
                <div class="stats-container">
                    <div class="stat-card">
                        <span class="stat-number" id="total-memory-blocks">0</span>
                        <span class="stat-label">è®°å¿†æ–¹å—</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number" id="visible-blocks">0</span>
                        <span class="stat-label">å¯è§æ–¹å—</span>
                    </div>
                </div>
            </div>

            <!-- æ–¹å—ç±»å‹ -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>ğŸ“¦</span> æ–¹å—ç±»å‹
                </div>
                <div class="blocks-list" id="memory-blocks-list">
                    <div class="block-type">ç­‰å¾…æ•°æ®...</div>
                </div>
            </div>

            <!-- æ“ä½œæ—¥å¿— -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>ğŸ“</span> æ“ä½œæ—¥å¿—
                </div>
                <div class="log-panel" id="log-content">
                    <div class="log-entry">ç³»ç»Ÿå¯åŠ¨ï¼Œç­‰å¾…è¿æ¥...</div>
                </div>
            </div>
        </div>

        <!-- å³ä¾§è§†å›¾åŒºåŸŸ -->
        <div class="views-container">
            <!-- 1åŒºåŸŸ - MineflyerVieweræ¸¸æˆç”»é¢ -->
            <div class="view-area viewer-area active">
                <div class="view-header">
                    <div class="view-title">
                        <span class="view-icon">ğŸ®</span>
                        <span>å®æ—¶æ¸¸æˆç”»é¢</span>
                    </div>
                    <div class="view-controls">
                        <button class="control-btn" onclick="refreshViewer()" title="åˆ·æ–°">ğŸ”„</button>
                        <button class="control-btn" onclick="toggleFullscreen('viewer')" title="å…¨å±">â›¶</button>
                    </div>
                </div>
                <div class="view-content">
                    <iframe 
                        class="viewer-iframe"
                        src="http://localhost:3007/" 
                        title="Prismarine Viewer"
                        id="viewer-iframe">
                    </iframe>
                </div>
            </div>

            <!-- 2åŒºåŸŸ - 2Dè§†é‡ -->
            <div class="view-area mini-map-area">
                <div class="view-header">
                    <div class="view-title">
                        <span class="view-icon">ğŸ—ºï¸</span>
                        <span>2D ä¿¯è§†å›¾</span>
                    </div>
                    <div class="view-controls">
                        <button class="control-btn" onclick="toggleMapMode()" title="åˆ‡æ¢æ¨¡å¼">ğŸ”„</button>
                        <button class="control-btn" onclick="toggleFullscreen('minimap')" title="å…¨å±">â›¶</button>
                    </div>
                </div>
                <div class="view-content">
                    <canvas class="mini-map-canvas" id="minimap-canvas"></canvas>
                    <div class="view-settings">
                        <div class="setting-item">
                            <label><input type="checkbox" id="show-grid-2d" checked> ç½‘æ ¼</label>
                        </div>
                        <div class="setting-item">
                            <label><input type="checkbox" id="show-trail-2d" checked> è½¨è¿¹</label>
                        </div>
                        <div class="setting-item">
                            <label>ç¼©æ”¾: <input type="range" id="map-scale" min="1" max="10" value="4"></label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3åŒºåŸŸ - 3Dç©ºé—´å»ºæ¨¡ -->
            <div class="view-area modeling-area">
                <div class="view-header">
                    <div class="view-title">
                        <span class="view-icon">ğŸ²</span>
                        <span>3D ç©ºé—´å»ºæ¨¡</span>
                    </div>
                    <div class="view-controls">
                        <button class="control-btn" onclick="resetCamera()" title="é‡ç½®è§†è§’">ğŸ“·</button>
                        <button class="control-btn" onclick="toggleFullscreen('modeling')" title="å…¨å±">â›¶</button>
                    </div>
                </div>
                <div class="view-content" id="modeling-view">
                    <div class="view-settings">
                        
                        <div class="setting-item">
                            <label><input type="checkbox" id="show-grid-3d" checked onchange="toggleGrid()"> ç½‘æ ¼</label>
                        </div>
                        <div class="setting-item">
                            <label><input type="checkbox" id="show-agent-trail" checked onchange="toggleAgentTrail()"> è½¨è¿¹</label>
                        </div>
                        <div class="setting-item">
                            <label><input type="checkbox" id="show-memory-only" checked onchange="toggleMemoryMode()"> è®°å¿†æ¨¡å¼</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let ws = null;
        let isConnected = false;
        let memoryOnlyMode = true;
        
        let agentData = {
            position: { x: 0, y: 0, z: 0 },
            yaw: 0,
            target: null,
            visibleBlocks: [],
            memoryBlocks: [],
            isNavigating: false
        };
        
        // Three.js 3D åœºæ™¯å˜é‡
        let scene, camera, renderer, controls;
        let agentMesh, targetMesh;
        let memoryBlockMeshes = new Map();
        let gridHelper;
        let agentTrail = [];
        let trailLine;
        
        // æ€§èƒ½ç»Ÿè®¡
        let renderStats = {
            blocksAdded: 0,
            blocksRemoved: 0,
            lastUpdate: Date.now()
        };
        
        // 2Då°åœ°å›¾äº¤äº’å˜é‡
        let minimapScale = 4;
        let minimapOffset = { x: 0, y: 0 };
        let isDraggingMinimap = false;
        let dragStart = { x: 0, y: 0 };
        let dragOrigin = { x: 0, y: 0 };
        
        // ä¸°å¯Œé¢œè‰²æ˜ å°„
        const blockColors = {
            'sand': '#F4E4BC',
            'grass_block': '#7CB342',
            'stone': '#808080',
            'dirt': '#8B4513',
            'water': '#2196F3',
            'wood': '#A0522D',
            'cobblestone': '#696969',
            'cactus': '#228B22',
            'dead_bush': '#8B4513',
            'lava': '#FF5722',
            'leaves': '#388E3C',
            'sandstone': '#E0C068',
            'ice': '#B3E5FC',
            'snow': '#FFFFFF',
            'clay': '#B0BEC5',
            'gravel': '#A89F91',
            'coal_ore': '#333333',
            'iron_ore': '#B87333',
            'gold_ore': '#FFD700',
            'diamond_ore': '#00E5EE',
            'redstone_ore': '#FF1744',
            'emerald_ore': '#00C853',
            'lapis_ore': '#1565C0',
            'glass': '#B0E0E6',
            'flower': '#FFB6C1',
            'tall_grass': '#A5D6A7',
            'tuff_bricks': '#7A6C5D',
            'polished_tuff': '#A89B8C',
            'deepslate': '#43464B',
            'waxed_copper_block': '#B87333',
            'waxed_oxidized_copper': '#6EC6B8',
            'lime_carpet': '#BFFF00',
            'waxed_oxidized_cut_copper': '#5CB8A6',
            'waxed_cut_copper_slab': '#B87333',
            'waxed_cut_copper': '#B87333',
            'waxed_exposed_copper_bulb': '#A0B2A6',
            'default': '#CCCCCC'
        };
        
        // åˆå§‹åŒ–
        function init() {
            init3DScene();
            connectWebSocket();
            updateCanvasSizes();
            
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', () => {
                setTimeout(updateCanvasSizes, 100);
            });
            
            // å®šæœŸæ›´æ–°æ€§èƒ½ç»Ÿè®¡
            setInterval(updatePerformanceStats, 2000);
        }
        
        // åˆå§‹åŒ–3Dåœºæ™¯
        function init3DScene() {
            const container = document.getElementById('modeling-view');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(20, 20, 20);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 0);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            gridHelper = new THREE.GridHelper(200, 200, 0x4CAF50, 0x333333);
            scene.add(gridHelper);
            
            createAgent();
            animate();
        }
        
        // åˆ›å»ºAgentæ¨¡å‹
        function createAgent() {
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            agentMesh = new THREE.Mesh(geometry, material);
            agentMesh.castShadow = true;
            scene.add(agentMesh);
            
            const arrowGeometry = new THREE.ConeGeometry(0.3, 1, 8);
            const arrowMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const arrowMesh = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrowMesh.position.set(0, 1.5, 0);
            agentMesh.add(arrowMesh);
        }
        
        // åˆ›å»ºç›®æ ‡æ ‡è®°
        function createTarget(position) {
            if (targetMesh) {
                scene.remove(targetMesh);
            }
            
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0xff4444,
                transparent: true,
                opacity: 0.8
            });
            targetMesh = new THREE.Mesh(geometry, material);
            targetMesh.position.set(position.x, position.y + 1, position.z);
            scene.add(targetMesh);
        }
        
        // æ™ºèƒ½æ›´æ–°è®°å¿†æ–¹å—
        function updateMemoryBlocks(newMemoryBlocks) {
            const newBlockKeys = new Set();
            const blocksToAdd = [];
            
            newMemoryBlocks.forEach(block => {
                const key = `${block.position.x},${block.position.y},${block.position.z}`;
                newBlockKeys.add(key);
                
                if (!memoryBlockMeshes.has(key)) {
                    blocksToAdd.push({ block, key });
                }
            });
            
            const blocksToRemove = [];
            for (const [key, mesh] of memoryBlockMeshes.entries()) {
                if (!newBlockKeys.has(key)) {
                    blocksToRemove.push(key);
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                    renderStats.blocksRemoved++;
                }
            }
            
            blocksToRemove.forEach(key => {
                memoryBlockMeshes.delete(key);
            });
            
            if (blocksToAdd.length > 0) {
                batchAddBlocks(blocksToAdd);
            }
            
            addLog(`è®°å¿†æ›´æ–°: +${blocksToAdd.length} -${blocksToRemove.length} æ–¹å—`);
        }
        
        // åˆ†æ‰¹æ·»åŠ æ–¹å—
        function batchAddBlocks(blocksToAdd, batchSize = 20) {
            let currentIndex = 0;
            
            function addBatch() {
                const endIndex = Math.min(currentIndex + batchSize, blocksToAdd.length);
                
                for (let i = currentIndex; i < endIndex; i++) {
                    const { block, key } = blocksToAdd[i];
                    createBlockMesh(block, key);
                }
                
                currentIndex = endIndex;
                renderStats.blocksAdded += (endIndex - (currentIndex - batchSize));
                
                if (currentIndex < blocksToAdd.length) {
                    requestAnimationFrame(addBatch);
                }
            }
            
            addBatch();
        }
        
        // åˆ›å»ºå•ä¸ªæ–¹å—Mesh
        function createBlockMesh(block, key) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const color = blockColors[block.type] || blockColors.default;
            // æ–°å¢ï¼šåŠé€æ˜æ–¹å—ç±»å‹
            const semiTransparentBlocks = [
                'tuff_bricks',
                'polished_tuff',
                'deepslate',
                'waxed_copper_block',
                'waxed_oxidized_copper',
                'lime_carpet',
                'waxed_oxidized_cut_copper',
                'waxed_cut_copper_slab',
                'waxed_cut_copper',
                'waxed_exposed_copper_bulb'
            ];
            const isSemiTransparent = semiTransparentBlocks.includes(block.type);
            const material = new THREE.MeshLambertMaterial({ 
                color,
                transparent: isSemiTransparent,
                opacity: isSemiTransparent ? 0.5 : 1.0
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(block.position.x, block.position.y, block.position.z);
            mesh.receiveShadow = true;
            mesh.castShadow = true;
            scene.add(mesh);
            memoryBlockMeshes.set(key, mesh);
        }
        
        // æ›´æ–°Agentä½ç½®å’Œè½¨è¿¹
        function updateAgent() {
            if (agentMesh && agentData.position) {
                agentMesh.position.set(
                    agentData.position.x,
                    agentData.position.y + 1,
                    agentData.position.z
                );
                agentMesh.rotation.y = agentData.yaw;
                
                if (document.getElementById('show-agent-trail').checked) {
                    updateAgentTrail();
                }
                
                controls.target.set(
                    agentData.position.x,
                    agentData.position.y,
                    agentData.position.z
                );
            }
        }
        
        // æ›´æ–°Agentè½¨è¿¹
        function updateAgentTrail() {
            agentTrail.push(new THREE.Vector3(
                agentData.position.x,
                agentData.position.y + 0.1,
                agentData.position.z
            ));
            
            if (agentTrail.length > 100) {
                agentTrail.shift();
            }
            
            if (trailLine) {
                scene.remove(trailLine);
            }
            
            if (agentTrail.length > 1) {
                const geometry = new THREE.BufferGeometry().setFromPoints(agentTrail);
                const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
                trailLine = new THREE.Line(geometry, material);
                scene.add(trailLine);
            }
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ç»˜åˆ¶2Då°åœ°å›¾
        function draw2DMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!agentData.position) return;
            const centerX = canvas.width / 2 + minimapOffset.x;
            const centerY = canvas.height / 2 + minimapOffset.y;
            const scale = minimapScale;
            // ç»˜åˆ¶ç½‘æ ¼
            if (document.getElementById('show-grid-2d').checked) {
                ctx.strokeStyle = 'rgba(76, 175, 80, 0.3)';
                ctx.lineWidth = 1;
                const gridSize = 10 * scale;
                for (let i = -canvas.width; i <= canvas.width; i += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(centerX + i, 0);
                    ctx.lineTo(centerX + i, canvas.height);
                    ctx.stroke();
                }
                for (let i = -canvas.height; i <= canvas.height; i += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, centerY + i);
                    ctx.lineTo(canvas.width, centerY + i);
                    ctx.stroke();
                }
            }
            // ç»˜åˆ¶è®°å¿†ä¸­çš„æ–¹å—
            if (agentData.memoryBlocks) {
                agentData.memoryBlocks.forEach(block => {
                    const x = centerX + (block.position.x - agentData.position.x) * scale;
                    const y = centerY + (block.position.z - agentData.position.z) * scale;
                    if (x >= -5 && x < canvas.width + 5 && y >= -5 && y < canvas.height + 5) {
                        // ä¸°å¯Œé¢œè‰²
                        let color = blockColors[block.type];
                        if (!color) {
                            if (block.type.includes('leaves')) color = blockColors['leaves'];
                            else if (block.type.includes('ore')) color = blockColors['stone'];
                            else if (block.type.includes('glass')) color = blockColors['glass'];
                            else if (block.type.includes('flower')) color = blockColors['flower'];
                            else if (block.type.includes('grass')) color = blockColors['grass_block'];
                            else color = blockColors['default'];
                        }
                        ctx.fillStyle = color;
                        const blockSize = Math.max(1, scale / 2);
                        ctx.fillRect(x - blockSize/2, y - blockSize/2, blockSize, blockSize);
                    }
                });
            }
            // ç»˜åˆ¶å¯è§æ–¹å—ï¼ˆä¸åŒé¢œè‰²ï¼‰
            if (agentData.visibleBlocks && !memoryOnlyMode) {
                agentData.visibleBlocks.forEach(block => {
                    const x = centerX + (block.position.x - agentData.position.x) * scale;
                    const y = centerY + (block.position.z - agentData.position.z) * scale;
                    
                    if (x >= -5 && x < canvas.width + 5 && y >= -5 && y < canvas.height + 5) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        const blockSize = Math.max(1, scale / 2);
                        ctx.fillRect(x - blockSize/2, y - blockSize/2, blockSize, blockSize);
                    }
                });
            }
            
            // ç»˜åˆ¶ç›®æ ‡
            if (agentData.target) {
                ctx.fillStyle = '#ff4444';
                const targetX = centerX + (agentData.target.x - agentData.position.x) * scale;
                const targetY = centerY + (agentData.target.z - agentData.position.z) * scale;
                ctx.beginPath();
                ctx.arc(targetX, targetY, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // ç»˜åˆ¶ç›®æ ‡æŒ‡ç¤ºçº¿
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(targetX, targetY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // ç»˜åˆ¶è½¨è¿¹
            if (document.getElementById('show-trail-2d').checked && agentTrail.length > 1) {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                agentTrail.forEach((point, index) => {
                    const x = centerX + (point.x - agentData.position.x) * scale;
                    const y = centerY + (point.z - agentData.position.z) * scale;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            }
            
            // ç»˜åˆ¶Agent
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(agentData.yaw);
            
            // Agentèº«ä½“
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(-6, -6, 12, 12);
            
            // Agentæœå‘æŒ‡ç¤º
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.lineTo(-4, -6);
            ctx.lineTo(4, -6);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // ç»˜åˆ¶åæ ‡ä¿¡æ¯
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(5, 5, 200, 40);
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px monospace';
            ctx.fillText(`ä½ç½®: ${agentData.position.x.toFixed(1)}, ${agentData.position.z.toFixed(1)}`, 10, 20);
            ctx.fillText(`æ–¹å—: ${agentData.memoryBlocks ? agentData.memoryBlocks.length : 0}`, 10, 35);
        }
        
        // WebSocketè¿æ¥
        function connectWebSocket() {
            try {
                ws = new WebSocket('ws://localhost:3008');
                
                ws.onopen = () => {
                    isConnected = true;
                    updateConnectionStatus(true);
                    addLog('WebSocketè¿æ¥æˆåŠŸ');
                    
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'requestMemory' }));
                    }
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleMessage(data);
                    } catch (error) {
                        console.error('è§£ææ¶ˆæ¯å¤±è´¥:', error);
                    }
                };
                
                ws.onclose = () => {
                    isConnected = false;
                    updateConnectionStatus(false);
                    addLog('WebSocketè¿æ¥æ–­å¼€ï¼Œ3ç§’åé‡è¿...');
                    setTimeout(connectWebSocket, 3000);
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocketé”™è¯¯:', error);
                };
            } catch (error) {
                addLog('è¿æ¥å¤±è´¥: ' + error.message);
                setTimeout(connectWebSocket, 3000);
            }
        }
        
        // å¤„ç†æ”¶åˆ°çš„æ¶ˆæ¯
        function handleMessage(data) {
            if (data.type === 'agentState') {
                agentData.position = data.position;
                agentData.yaw = data.yaw;
                agentData.target = data.target;
                agentData.isNavigating = data.isNavigating;
                agentData.visibleBlocks = data.visibleBlocks || [];
                
                updateUI();
                updateAgent();
                
                if (agentData.target) {
                    createTarget(agentData.target);
                } else if (targetMesh) {
                    scene.remove(targetMesh);
                    targetMesh = null;
                }
                
                draw2DMinimap();
                
            } else if (data.type === 'memoryBlocks') {
                agentData.memoryBlocks = data.blocks || [];
                
                updateMemoryBlocks(agentData.memoryBlocks);
                updateMemoryBlocksList();
                addLog(`è®°å¿†æ›´æ–°ï¼šå…±${agentData.memoryBlocks.length}ä¸ªæ–¹å—`);
            }
        }
        
        // æ›´æ–°UIå…ƒç´ 
        function updateUI() {
            document.getElementById('pos-x').textContent = agentData.position.x.toFixed(2);
            document.getElementById('pos-y').textContent = agentData.position.y.toFixed(2);
            document.getElementById('pos-z').textContent = agentData.position.z.toFixed(2);
            document.getElementById('pos-yaw').textContent = (agentData.yaw * 180 / Math.PI).toFixed(2) + 'Â°';
            document.getElementById('nav-status').textContent = agentData.isNavigating ? 'å¯¼èˆªä¸­' : 'å¾…æœº';
            
            if (agentData.target) {
                document.getElementById('target-x').textContent = agentData.target.x.toFixed(2);
                document.getElementById('target-y').textContent = agentData.target.y.toFixed(2);
                document.getElementById('target-z').textContent = agentData.target.z.toFixed(2);
                
                const distance = Math.sqrt(
                    Math.pow(agentData.target.x - agentData.position.x, 2) +
                    Math.pow(agentData.target.y - agentData.position.y, 2) +
                    Math.pow(agentData.target.z - agentData.position.z, 2)
                );
                document.getElementById('target-distance').textContent = distance.toFixed(2) + ' m';
            } else {
                document.getElementById('target-x').textContent = '--';
                document.getElementById('target-y').textContent = '--';
                document.getElementById('target-z').textContent = '--';
                document.getElementById('target-distance').textContent = '-- m';
            }
            
            document.getElementById('total-memory-blocks').textContent = agentData.memoryBlocks ? agentData.memoryBlocks.length : 0;
            document.getElementById('visible-blocks').textContent = agentData.visibleBlocks.length;
        }
        
        // æ›´æ–°è®°å¿†æ–¹å—åˆ—è¡¨
        function updateMemoryBlocksList() {
            const blocksList = document.getElementById('memory-blocks-list');
            if (agentData.memoryBlocks && agentData.memoryBlocks.length > 0) {
                const typeCount = {};
                agentData.memoryBlocks.forEach(block => {
                    typeCount[block.type] = (typeCount[block.type] || 0) + 1;
                });
                
                const sortedTypes = Object.entries(typeCount)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);
                
                blocksList.innerHTML = sortedTypes
                    .map(([type, count]) => {
                        return `<div class="block-type"><span>${type}</span><span>${count}</span></div>`;
                    })
                    .join('');
            } else {
                blocksList.innerHTML = '<div class="block-type">æ— è®°å¿†æ–¹å—</div>';
            }
        }
        
        // æ›´æ–°æ€§èƒ½ç»Ÿè®¡
        function updatePerformanceStats() {
            const timeSinceUpdate = (Date.now() - renderStats.lastUpdate) / 1000;
            
            renderStats.blocksAdded = 0;
            renderStats.blocksRemoved = 0;
            renderStats.lastUpdate = Date.now();
        }
        
        // æ§åˆ¶å‡½æ•°
        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connection-indicator');
            const text = document.getElementById('connection-text');
            
            if (connected) {
                indicator.classList.add('connected');
                text.textContent = 'å·²è¿æ¥ - è®°å¿†æ¨¡å¼';
            } else {
                indicator.classList.remove('connected');
                text.textContent = 'æœªè¿æ¥';
            }
        }
        
        function sendMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log('å‘é€æ¶ˆæ¯', message);
                ws.send(JSON.stringify(message));
                return true;
            } else {
                addLog('å‘é€å¤±è´¥: WebSocketæœªè¿æ¥');
                return false;
            }
        }
        
        function navigateTo() {
            const x = parseFloat(document.getElementById('nav-x').value);
            const y = parseFloat(document.getElementById('nav-y').value);
            const z = parseFloat(document.getElementById('nav-z').value);
            
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                if (sendMessage({
                    type: 'command',
                    command: 'navigate',
                    target: { x, y, z }
                })) {
                    addLog(`å¼€å§‹å¯¼èˆªåˆ° (${x}, ${y}, ${z})`);
                }
            } else {
                addLog('è¯·è¾“å…¥æœ‰æ•ˆçš„åæ ‡');
            }
        }
        
        function stopNavigation() {
            if (sendMessage({
                type: 'command',
                command: 'stop'
            })) {
                addLog('åœæ­¢å¯¼èˆª');
            }
        }
        
        function getStatus() {
            if (sendMessage({
                type: 'command',
                command: 'status'
            })) {
                addLog('è¯·æ±‚çŠ¶æ€æ›´æ–°');
            }
        }
        
        function getCurrentPos() {
            if (agentData.position) {
                document.getElementById('nav-x').value = agentData.position.x.toFixed(1);
                document.getElementById('nav-y').value = agentData.position.y.toFixed(1);
                document.getElementById('nav-z').value = agentData.position.z.toFixed(1);
                addLog('å½“å‰ä½ç½®å·²å¡«å…¥å¯¼èˆªæ¡†');
            }
        }
        
        function updateViewDistance() {
            const value = document.getElementById('view-distance').value;
            document.getElementById('view-distance-value').textContent = value;
            console.log('setViewDistance', value);
            sendMessage({ type: 'setViewDistance', value: Number(value) });
        }
        
        function toggleGrid() {
            if (gridHelper) {
                gridHelper.visible = document.getElementById('show-grid-3d').checked;
            }
        }
        
        function toggleAgentTrail() {
            if (!document.getElementById('show-agent-trail').checked && trailLine) {
                scene.remove(trailLine);
                trailLine = null;
                agentTrail = [];
            }
        }
        
        function toggleMemoryMode() {
            memoryOnlyMode = document.getElementById('show-memory-only').checked;
            addLog(memoryOnlyMode ? 'åˆ‡æ¢ä¸ºè®°å¿†æ¨¡å¼' : 'åˆ‡æ¢ä¸ºå®æ—¶æ¨¡å¼');
        }
        
        function addLog(message) {
            const logContent = document.getElementById('log-content');
            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `[${time}] ${message}`;
            logContent.appendChild(logEntry);
            logContent.scrollTop = logContent.scrollHeight;
            
            while (logContent.children.length > 15) {
                logContent.removeChild(logContent.firstChild);
            }
        }
        
        function updateCanvasSizes() {
            // æ›´æ–°3Dæ¸²æŸ“å™¨å¤§å°
            if (renderer) {
                const container = document.getElementById('modeling-view');
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
            
            // æ›´æ–°2Dç”»å¸ƒå¤§å°
            const canvas = document.getElementById('minimap-canvas');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // é‡æ–°ç»˜åˆ¶2Dåœ°å›¾
            draw2DMinimap();
        }
        
        // è§†å›¾æ§åˆ¶å‡½æ•°
        function refreshViewer() {
            const iframe = document.getElementById('viewer-iframe');
            iframe.src = iframe.src;
            addLog('åˆ·æ–°æ¸¸æˆç”»é¢');
        }
        
        function toggleFullscreen(viewType) {
            addLog(`åˆ‡æ¢${viewType}å…¨å±æ¨¡å¼`);
            // è¿™é‡Œå¯ä»¥å®ç°å…¨å±åŠŸèƒ½
        }
        
        function toggleMapMode() {
            memoryOnlyMode = !memoryOnlyMode;
            document.getElementById('show-memory-only').checked = memoryOnlyMode;
            addLog(`2Dåœ°å›¾åˆ‡æ¢ä¸º${memoryOnlyMode ? 'è®°å¿†' : 'å®æ—¶'}æ¨¡å¼`);
            draw2DMinimap();
        }
        
        function resetCamera() {
            if (camera && controls) {
                camera.position.set(20, 20, 20);
                if (agentData.position) {
                    controls.target.set(
                        agentData.position.x,
                        agentData.position.y,
                        agentData.position.z
                    );
                }
                controls.update();
                addLog('é‡ç½®3Dè§†è§’');
            }
        }
        
        // ç›‘å¬åœ°å›¾ç¼©æ”¾å˜åŒ–
        document.getElementById('map-scale').addEventListener('input', function() {
            draw2DMinimap();
        });
        
        // ç›‘å¬ç½‘æ ¼å’Œè½¨è¿¹æ˜¾ç¤ºè®¾ç½®
        document.getElementById('show-grid-2d').addEventListener('change', draw2DMinimap);
        document.getElementById('show-trail-2d').addEventListener('change', draw2DMinimap);
        
        // ç›‘å¬æ»šè½®ç¼©æ”¾
        document.getElementById('minimap-canvas').addEventListener('wheel', function(e) {
            e.preventDefault();
            const oldScale = minimapScale;
            if (e.deltaY < 0) {
                minimapScale = Math.min(20, minimapScale + 1);
            } else {
                minimapScale = Math.max(1, minimapScale - 1);
            }
            // ç¼©æ”¾æ—¶ä»¥é¼ æ ‡ä¸ºä¸­å¿ƒè°ƒæ•´åç§»
            const rect = this.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            minimapOffset.x = (minimapOffset.x - mx) * (minimapScale / oldScale) + mx;
            minimapOffset.y = (minimapOffset.y - my) * (minimapScale / oldScale) + my;
            draw2DMinimap();
        }, { passive: false });

        // ç›‘å¬é¼ æ ‡æ‹–åŠ¨
        const minimapCanvas = document.getElementById('minimap-canvas');
        minimapCanvas.addEventListener('mousedown', function(e) {
            isDraggingMinimap = true;
            dragStart = { x: e.clientX, y: e.clientY };
            dragOrigin = { x: minimapOffset.x, y: minimapOffset.y };
        });
        window.addEventListener('mousemove', function(e) {
            if (isDraggingMinimap) {
                minimapOffset.x = dragOrigin.x + (e.clientX - dragStart.x);
                minimapOffset.y = dragOrigin.y + (e.clientY - dragStart.y);
                draw2DMinimap();
            }
        });
        window.addEventListener('mouseup', function() {
            isDraggingMinimap = false;
        });
        
        // å¯åŠ¨åº”ç”¨
        init();
        
        // å®šæœŸè¯·æ±‚è®°å¿†æ•°æ®
        setInterval(() => {
            if (isConnected && memoryOnlyMode) {
                sendMessage({ type: 'requestMemory' });
            }
        }, 1000);
        
        // å®šæœŸé‡ç»˜2Dåœ°å›¾
        setInterval(() => {
            if (agentData.position) {
                draw2DMinimap();
            }
        }, 100);
    </script>
</body>
</html>
