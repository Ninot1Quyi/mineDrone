<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MineDrone 3D可视化界面</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e1e, #2d2d2d);
            color: white;
            overflow: hidden;
        }

        .main-container {
            display: grid;
            grid-template-columns: 350px 1fr;
            grid-template-rows: 1fr;
            height: 100vh;
            gap: 1px;
        }

        /* 左侧控制面板 */
        .control-panel {
            background: linear-gradient(180deg, #2a2a2a, #1e1e1e);
            border-right: 2px solid #4CAF50;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 4px 0 20px rgba(0,0,0,0.3);
        }

        /* 右侧视图区域 */
        .views-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 2px;
            background: #1a1a1a;
            padding: 2px;
        }

        /* 视图区域样式 */
        .view-area {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            border: 2px solid transparent;
            background: #000;
            transition: border-color 0.3s ease;
        }

        .view-area:hover {
            border-color: #4CAF50;
        }

        .view-area.active {
            border-color: #FFD700;
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.3);
        }

        .view-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(76, 175, 80, 0.9), rgba(76, 175, 80, 0.7));
            padding: 8px 15px;
            font-weight: bold;
            font-size: 14px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .view-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .view-icon {
            font-size: 16px;
        }

        .view-controls {
            display: flex;
            gap: 5px;
        }

        .control-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .view-content {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* 1区域 - MineflyerViewer游戏画面 */
        .viewer-area {
            grid-column: 1;
            grid-row: 1 / 3;
        }

        .viewer-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: #222;
        }

        /* 2区域 - 2D视野 */
        .mini-map-area {
            grid-column: 2;
            grid-row: 1;
        }

        .mini-map-canvas {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
        }

        /* 3区域 - 3D空间建模 */
        .modeling-area {
            grid-column: 2;
            grid-row: 2;
        }

        /* 控制面板元素样式 */
        .panel-section {
            background: linear-gradient(145deg, #3a3a3a, #2d2d2d);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(76, 175, 80, 0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .panel-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #4CAF50;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 8px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f44336;
            animation: pulse 2s infinite;
            margin-right: 8px;
        }

        .status-indicator.connected {
            background: #4CAF50;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
        }

        .info-item {
            background: rgba(255,255,255,0.05);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            border-left: 3px solid #4CAF50;
        }

        .info-label {
            font-size: 11px;
            opacity: 0.8;
            margin-bottom: 4px;
        }

        .info-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #FFD700;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
        }

        .btn {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.danger {
            background: linear-gradient(145deg, #f44336, #d32f2f);
            box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
        }

        .btn.danger:hover {
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
        }

        .input-group {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }

        .coord-input {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(76, 175, 80, 0.5);
            color: white;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        .coord-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
        }

        .stats-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-card {
            background: linear-gradient(145deg, #4a4a4a, #3d3d3d);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border-top: 3px solid #FFD700;
        }

        .stat-number {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
            display: block;
        }

        .stat-label {
            font-size: 10px;
            opacity: 0.8;
        }

        .blocks-list {
            max-height: 120px;
            overflow-y: auto;
            background: #1a1a1a;
            border-radius: 8px;
            padding: 8px;
        }

        .block-type {
            background: rgba(76, 175, 80, 0.1);
            margin: 3px 0;
            padding: 6px 8px;
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
        }

        .log-panel {
            max-height: 100px;
            overflow-y: auto;
            background: #1a1a1a;
            border-radius: 8px;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .log-entry:nth-child(odd) {
            background: rgba(255,255,255,0.02);
        }

        /* 视图特定样式 */
        .view-settings {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 6px;
            font-size: 10px;
            z-index: 200;
        }

        .setting-item {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 3px 0;
        }

        .setting-item input[type="checkbox"] {
            width: 12px;
            height: 12px;
        }

        .setting-item input[type="range"] {
            width: 60px;
            height: 16px;
        }

        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        /* 响应式设计 */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 300px 1fr;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            
            .control-panel {
                max-height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- 左侧控制面板 -->
        <div class="control-panel">
            <!-- 连接状态 -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>🔗</span> 连接状态
                </div>
                <div style="display: flex; align-items: center;">
                    <div class="status-indicator" id="connection-indicator"></div>
                    <span id="connection-text">正在连接...</span>
                </div>
            </div>

            <!-- Agent状态 -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>🤖</span> Agent状态
                </div>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">位置 X</div>
                        <div class="info-value" id="pos-x">0.00</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">位置 Y</div>
                        <div class="info-value" id="pos-y">0.00</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">位置 Z</div>
                        <div class="info-value" id="pos-z">0.00</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">朝向</div>
                        <div class="info-value" id="pos-yaw">0.00°</div>
                    </div>
                </div>
                <div class="info-item" style="grid-column: 1 / -1; margin-top: 8px;">
                    <div class="info-label">状态</div>
                    <div class="info-value" id="nav-status">待机</div>
                </div>
            </div>

            <!-- 导航控制 -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>🎮</span> 导航控制
                </div>
                <div class="input-group" style="gap:2px;">
                    <input type="number" class="coord-input" id="nav-x" placeholder="X" step="0.1" style="width:60px;">
                    <input type="number" class="coord-input" id="nav-y" placeholder="Y" step="0.1" style="width:60px;">
                    <input type="number" class="coord-input" id="nav-z" placeholder="Z" step="0.1" style="width:60px;">
                </div>
                <div class="control-buttons">
                    <button class="btn" onclick="navigateTo()">🚀 导航</button>
                    <button class="btn danger" onclick="stopNavigation()">⛔ 停止</button>
                    <button class="btn" onclick="getCurrentPos()">📍 当前</button>
                    <button class="btn" onclick="getStatus()">🔄 刷新</button>
                </div>
            </div>

            <!-- 目标信息 -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>🎯</span> 目标信息
                </div>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">目标 X</div>
                        <div class="info-value" id="target-x">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">目标 Y</div>
                        <div class="info-value" id="target-y">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">目标 Z</div>
                        <div class="info-value" id="target-z">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">距离</div>
                        <div class="info-value" id="target-distance">-- m</div>
                    </div>
                </div>
            </div>

            <!-- 记忆统计 -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>📊</span> 记忆统计
                </div>
                <div class="stats-container">
                    <div class="stat-card">
                        <span class="stat-number" id="total-memory-blocks">0</span>
                        <span class="stat-label">记忆方块</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number" id="visible-blocks">0</span>
                        <span class="stat-label">可见方块</span>
                    </div>
                </div>
            </div>

            <!-- 方块类型 -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>📦</span> 方块类型
                </div>
                <div class="blocks-list" id="memory-blocks-list">
                    <div class="block-type">等待数据...</div>
                </div>
            </div>

            <!-- 操作日志 -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>📝</span> 操作日志
                </div>
                <div class="log-panel" id="log-content">
                    <div class="log-entry">系统启动，等待连接...</div>
                </div>
            </div>
        </div>

        <!-- 右侧视图区域 -->
        <div class="views-container">
            <!-- 1区域 - MineflyerViewer游戏画面 -->
            <div class="view-area viewer-area active">
                <div class="view-header">
                    <div class="view-title">
                        <span class="view-icon">🎮</span>
                        <span>实时游戏画面</span>
                    </div>
                    <div class="view-controls">
                        <button class="control-btn" onclick="refreshViewer()" title="刷新">🔄</button>
                        <button class="control-btn" onclick="toggleFullscreen('viewer')" title="全屏">⛶</button>
                    </div>
                </div>
                <div class="view-content">
                    <iframe 
                        class="viewer-iframe"
                        src="http://localhost:3007/" 
                        title="Prismarine Viewer"
                        id="viewer-iframe">
                    </iframe>
                </div>
            </div>

            <!-- 2区域 - 2D视野 -->
            <div class="view-area mini-map-area">
                <div class="view-header">
                    <div class="view-title">
                        <span class="view-icon">🗺️</span>
                        <span>2D 俯视图</span>
                    </div>
                    <div class="view-controls">
                        <button class="control-btn" onclick="toggleMapMode()" title="切换模式">🔄</button>
                        <button class="control-btn" onclick="toggleFullscreen('minimap')" title="全屏">⛶</button>
                    </div>
                </div>
                <div class="view-content">
                    <canvas class="mini-map-canvas" id="minimap-canvas"></canvas>
                    <div class="view-settings">
                        <div class="setting-item">
                            <label><input type="checkbox" id="show-grid-2d" checked> 网格</label>
                        </div>
                        <div class="setting-item">
                            <label><input type="checkbox" id="show-trail-2d" checked> 轨迹</label>
                        </div>
                        <div class="setting-item">
                            <label>缩放: <input type="range" id="map-scale" min="1" max="10" value="4"></label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3区域 - 3D空间建模 -->
            <div class="view-area modeling-area">
                <div class="view-header">
                    <div class="view-title">
                        <span class="view-icon">🎲</span>
                        <span>3D 空间建模</span>
                    </div>
                    <div class="view-controls">
                        <button class="control-btn" onclick="resetCamera()" title="重置视角">📷</button>
                        <button class="control-btn" onclick="toggleFullscreen('modeling')" title="全屏">⛶</button>
                    </div>
                </div>
                <div class="view-content" id="modeling-view">
                    <div class="view-settings">
                        
                        <div class="setting-item">
                            <label><input type="checkbox" id="show-grid-3d" checked onchange="toggleGrid()"> 网格</label>
                        </div>
                        <div class="setting-item">
                            <label><input type="checkbox" id="show-agent-trail" checked onchange="toggleAgentTrail()"> 轨迹</label>
                        </div>
                        <div class="setting-item">
                            <label><input type="checkbox" id="show-memory-only" checked onchange="toggleMemoryMode()"> 记忆模式</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let ws = null;
        let isConnected = false;
        let memoryOnlyMode = true;
        
        let agentData = {
            position: { x: 0, y: 0, z: 0 },
            yaw: 0,
            target: null,
            visibleBlocks: [],
            memoryBlocks: [],
            isNavigating: false
        };
        
        // Three.js 3D 场景变量
        let scene, camera, renderer, controls;
        let agentMesh, targetMesh;
        let memoryBlockMeshes = new Map();
        let gridHelper;
        let agentTrail = [];
        let trailLine;
        
        // 性能统计
        let renderStats = {
            blocksAdded: 0,
            blocksRemoved: 0,
            lastUpdate: Date.now()
        };
        
        // 2D小地图交互变量
        let minimapScale = 4;
        let minimapOffset = { x: 0, y: 0 };
        let isDraggingMinimap = false;
        let dragStart = { x: 0, y: 0 };
        let dragOrigin = { x: 0, y: 0 };
        
        // 丰富颜色映射
        const blockColors = {
            'sand': '#F4E4BC',
            'grass_block': '#7CB342',
            'stone': '#808080',
            'dirt': '#8B4513',
            'water': '#2196F3',
            'wood': '#A0522D',
            'cobblestone': '#696969',
            'cactus': '#228B22',
            'dead_bush': '#8B4513',
            'lava': '#FF5722',
            'leaves': '#388E3C',
            'sandstone': '#E0C068',
            'ice': '#B3E5FC',
            'snow': '#FFFFFF',
            'clay': '#B0BEC5',
            'gravel': '#A89F91',
            'coal_ore': '#333333',
            'iron_ore': '#B87333',
            'gold_ore': '#FFD700',
            'diamond_ore': '#00E5EE',
            'redstone_ore': '#FF1744',
            'emerald_ore': '#00C853',
            'lapis_ore': '#1565C0',
            'glass': '#B0E0E6',
            'flower': '#FFB6C1',
            'tall_grass': '#A5D6A7',
            'tuff_bricks': '#7A6C5D',
            'polished_tuff': '#A89B8C',
            'deepslate': '#43464B',
            'waxed_copper_block': '#B87333',
            'waxed_oxidized_copper': '#6EC6B8',
            'lime_carpet': '#BFFF00',
            'waxed_oxidized_cut_copper': '#5CB8A6',
            'waxed_cut_copper_slab': '#B87333',
            'waxed_cut_copper': '#B87333',
            'waxed_exposed_copper_bulb': '#A0B2A6',
            'default': '#CCCCCC'
        };
        
        // 初始化
        function init() {
            init3DScene();
            connectWebSocket();
            updateCanvasSizes();
            
            // 监听窗口大小变化
            window.addEventListener('resize', () => {
                setTimeout(updateCanvasSizes, 100);
            });
            
            // 定期更新性能统计
            setInterval(updatePerformanceStats, 2000);
        }
        
        // 初始化3D场景
        function init3DScene() {
            const container = document.getElementById('modeling-view');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(20, 20, 20);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 0);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            gridHelper = new THREE.GridHelper(200, 200, 0x4CAF50, 0x333333);
            scene.add(gridHelper);
            
            createAgent();
            animate();
        }
        
        // 创建Agent模型
        function createAgent() {
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            agentMesh = new THREE.Mesh(geometry, material);
            agentMesh.castShadow = true;
            scene.add(agentMesh);
            
            const arrowGeometry = new THREE.ConeGeometry(0.3, 1, 8);
            const arrowMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const arrowMesh = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrowMesh.position.set(0, 1.5, 0);
            agentMesh.add(arrowMesh);
        }
        
        // 创建目标标记
        function createTarget(position) {
            if (targetMesh) {
                scene.remove(targetMesh);
            }
            
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0xff4444,
                transparent: true,
                opacity: 0.8
            });
            targetMesh = new THREE.Mesh(geometry, material);
            targetMesh.position.set(position.x, position.y + 1, position.z);
            scene.add(targetMesh);
        }
        
        // 智能更新记忆方块
        function updateMemoryBlocks(newMemoryBlocks) {
            const newBlockKeys = new Set();
            const blocksToAdd = [];
            
            newMemoryBlocks.forEach(block => {
                const key = `${block.position.x},${block.position.y},${block.position.z}`;
                newBlockKeys.add(key);
                
                if (!memoryBlockMeshes.has(key)) {
                    blocksToAdd.push({ block, key });
                }
            });
            
            const blocksToRemove = [];
            for (const [key, mesh] of memoryBlockMeshes.entries()) {
                if (!newBlockKeys.has(key)) {
                    blocksToRemove.push(key);
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                    renderStats.blocksRemoved++;
                }
            }
            
            blocksToRemove.forEach(key => {
                memoryBlockMeshes.delete(key);
            });
            
            if (blocksToAdd.length > 0) {
                batchAddBlocks(blocksToAdd);
            }
            
            addLog(`记忆更新: +${blocksToAdd.length} -${blocksToRemove.length} 方块`);
        }
        
        // 分批添加方块
        function batchAddBlocks(blocksToAdd, batchSize = 20) {
            let currentIndex = 0;
            
            function addBatch() {
                const endIndex = Math.min(currentIndex + batchSize, blocksToAdd.length);
                
                for (let i = currentIndex; i < endIndex; i++) {
                    const { block, key } = blocksToAdd[i];
                    createBlockMesh(block, key);
                }
                
                currentIndex = endIndex;
                renderStats.blocksAdded += (endIndex - (currentIndex - batchSize));
                
                if (currentIndex < blocksToAdd.length) {
                    requestAnimationFrame(addBatch);
                }
            }
            
            addBatch();
        }
        
        // 创建单个方块Mesh
        function createBlockMesh(block, key) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const color = blockColors[block.type] || blockColors.default;
            // 新增：半透明方块类型
            const semiTransparentBlocks = [
                'tuff_bricks',
                'polished_tuff',
                'deepslate',
                'waxed_copper_block',
                'waxed_oxidized_copper',
                'lime_carpet',
                'waxed_oxidized_cut_copper',
                'waxed_cut_copper_slab',
                'waxed_cut_copper',
                'waxed_exposed_copper_bulb'
            ];
            const isSemiTransparent = semiTransparentBlocks.includes(block.type);
            const material = new THREE.MeshLambertMaterial({ 
                color,
                transparent: isSemiTransparent,
                opacity: isSemiTransparent ? 0.5 : 1.0
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(block.position.x, block.position.y, block.position.z);
            mesh.receiveShadow = true;
            mesh.castShadow = true;
            scene.add(mesh);
            memoryBlockMeshes.set(key, mesh);
        }
        
        // 更新Agent位置和轨迹
        function updateAgent() {
            if (agentMesh && agentData.position) {
                agentMesh.position.set(
                    agentData.position.x,
                    agentData.position.y + 1,
                    agentData.position.z
                );
                agentMesh.rotation.y = agentData.yaw;
                
                if (document.getElementById('show-agent-trail').checked) {
                    updateAgentTrail();
                }
                
                controls.target.set(
                    agentData.position.x,
                    agentData.position.y,
                    agentData.position.z
                );
            }
        }
        
        // 更新Agent轨迹
        function updateAgentTrail() {
            agentTrail.push(new THREE.Vector3(
                agentData.position.x,
                agentData.position.y + 0.1,
                agentData.position.z
            ));
            
            if (agentTrail.length > 100) {
                agentTrail.shift();
            }
            
            if (trailLine) {
                scene.remove(trailLine);
            }
            
            if (agentTrail.length > 1) {
                const geometry = new THREE.BufferGeometry().setFromPoints(agentTrail);
                const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
                trailLine = new THREE.Line(geometry, material);
                scene.add(trailLine);
            }
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // 绘制2D小地图
        function draw2DMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!agentData.position) return;
            const centerX = canvas.width / 2 + minimapOffset.x;
            const centerY = canvas.height / 2 + minimapOffset.y;
            const scale = minimapScale;
            // 绘制网格
            if (document.getElementById('show-grid-2d').checked) {
                ctx.strokeStyle = 'rgba(76, 175, 80, 0.3)';
                ctx.lineWidth = 1;
                const gridSize = 10 * scale;
                for (let i = -canvas.width; i <= canvas.width; i += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(centerX + i, 0);
                    ctx.lineTo(centerX + i, canvas.height);
                    ctx.stroke();
                }
                for (let i = -canvas.height; i <= canvas.height; i += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, centerY + i);
                    ctx.lineTo(canvas.width, centerY + i);
                    ctx.stroke();
                }
            }
            // 绘制记忆中的方块
            if (agentData.memoryBlocks) {
                agentData.memoryBlocks.forEach(block => {
                    const x = centerX + (block.position.x - agentData.position.x) * scale;
                    const y = centerY + (block.position.z - agentData.position.z) * scale;
                    if (x >= -5 && x < canvas.width + 5 && y >= -5 && y < canvas.height + 5) {
                        // 丰富颜色
                        let color = blockColors[block.type];
                        if (!color) {
                            if (block.type.includes('leaves')) color = blockColors['leaves'];
                            else if (block.type.includes('ore')) color = blockColors['stone'];
                            else if (block.type.includes('glass')) color = blockColors['glass'];
                            else if (block.type.includes('flower')) color = blockColors['flower'];
                            else if (block.type.includes('grass')) color = blockColors['grass_block'];
                            else color = blockColors['default'];
                        }
                        ctx.fillStyle = color;
                        const blockSize = Math.max(1, scale / 2);
                        ctx.fillRect(x - blockSize/2, y - blockSize/2, blockSize, blockSize);
                    }
                });
            }
            // 绘制可见方块（不同颜色）
            if (agentData.visibleBlocks && !memoryOnlyMode) {
                agentData.visibleBlocks.forEach(block => {
                    const x = centerX + (block.position.x - agentData.position.x) * scale;
                    const y = centerY + (block.position.z - agentData.position.z) * scale;
                    
                    if (x >= -5 && x < canvas.width + 5 && y >= -5 && y < canvas.height + 5) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        const blockSize = Math.max(1, scale / 2);
                        ctx.fillRect(x - blockSize/2, y - blockSize/2, blockSize, blockSize);
                    }
                });
            }
            
            // 绘制目标
            if (agentData.target) {
                ctx.fillStyle = '#ff4444';
                const targetX = centerX + (agentData.target.x - agentData.position.x) * scale;
                const targetY = centerY + (agentData.target.z - agentData.position.z) * scale;
                ctx.beginPath();
                ctx.arc(targetX, targetY, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // 绘制目标指示线
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(targetX, targetY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // 绘制轨迹
            if (document.getElementById('show-trail-2d').checked && agentTrail.length > 1) {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                agentTrail.forEach((point, index) => {
                    const x = centerX + (point.x - agentData.position.x) * scale;
                    const y = centerY + (point.z - agentData.position.z) * scale;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            }
            
            // 绘制Agent
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(agentData.yaw);
            
            // Agent身体
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(-6, -6, 12, 12);
            
            // Agent朝向指示
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.lineTo(-4, -6);
            ctx.lineTo(4, -6);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // 绘制坐标信息
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(5, 5, 200, 40);
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px monospace';
            ctx.fillText(`位置: ${agentData.position.x.toFixed(1)}, ${agentData.position.z.toFixed(1)}`, 10, 20);
            ctx.fillText(`方块: ${agentData.memoryBlocks ? agentData.memoryBlocks.length : 0}`, 10, 35);
        }
        
        // WebSocket连接
        function connectWebSocket() {
            try {
                ws = new WebSocket('ws://localhost:3008');
                
                ws.onopen = () => {
                    isConnected = true;
                    updateConnectionStatus(true);
                    addLog('WebSocket连接成功');
                    
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'requestMemory' }));
                    }
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleMessage(data);
                    } catch (error) {
                        console.error('解析消息失败:', error);
                    }
                };
                
                ws.onclose = () => {
                    isConnected = false;
                    updateConnectionStatus(false);
                    addLog('WebSocket连接断开，3秒后重连...');
                    setTimeout(connectWebSocket, 3000);
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket错误:', error);
                };
            } catch (error) {
                addLog('连接失败: ' + error.message);
                setTimeout(connectWebSocket, 3000);
            }
        }
        
        // 处理收到的消息
        function handleMessage(data) {
            if (data.type === 'agentState') {
                agentData.position = data.position;
                agentData.yaw = data.yaw;
                agentData.target = data.target;
                agentData.isNavigating = data.isNavigating;
                agentData.visibleBlocks = data.visibleBlocks || [];
                
                updateUI();
                updateAgent();
                
                if (agentData.target) {
                    createTarget(agentData.target);
                } else if (targetMesh) {
                    scene.remove(targetMesh);
                    targetMesh = null;
                }
                
                draw2DMinimap();
                
            } else if (data.type === 'memoryBlocks') {
                agentData.memoryBlocks = data.blocks || [];
                
                updateMemoryBlocks(agentData.memoryBlocks);
                updateMemoryBlocksList();
                addLog(`记忆更新：共${agentData.memoryBlocks.length}个方块`);
            }
        }
        
        // 更新UI元素
        function updateUI() {
            document.getElementById('pos-x').textContent = agentData.position.x.toFixed(2);
            document.getElementById('pos-y').textContent = agentData.position.y.toFixed(2);
            document.getElementById('pos-z').textContent = agentData.position.z.toFixed(2);
            document.getElementById('pos-yaw').textContent = (agentData.yaw * 180 / Math.PI).toFixed(2) + '°';
            document.getElementById('nav-status').textContent = agentData.isNavigating ? '导航中' : '待机';
            
            if (agentData.target) {
                document.getElementById('target-x').textContent = agentData.target.x.toFixed(2);
                document.getElementById('target-y').textContent = agentData.target.y.toFixed(2);
                document.getElementById('target-z').textContent = agentData.target.z.toFixed(2);
                
                const distance = Math.sqrt(
                    Math.pow(agentData.target.x - agentData.position.x, 2) +
                    Math.pow(agentData.target.y - agentData.position.y, 2) +
                    Math.pow(agentData.target.z - agentData.position.z, 2)
                );
                document.getElementById('target-distance').textContent = distance.toFixed(2) + ' m';
            } else {
                document.getElementById('target-x').textContent = '--';
                document.getElementById('target-y').textContent = '--';
                document.getElementById('target-z').textContent = '--';
                document.getElementById('target-distance').textContent = '-- m';
            }
            
            document.getElementById('total-memory-blocks').textContent = agentData.memoryBlocks ? agentData.memoryBlocks.length : 0;
            document.getElementById('visible-blocks').textContent = agentData.visibleBlocks.length;
        }
        
        // 更新记忆方块列表
        function updateMemoryBlocksList() {
            const blocksList = document.getElementById('memory-blocks-list');
            if (agentData.memoryBlocks && agentData.memoryBlocks.length > 0) {
                const typeCount = {};
                agentData.memoryBlocks.forEach(block => {
                    typeCount[block.type] = (typeCount[block.type] || 0) + 1;
                });
                
                const sortedTypes = Object.entries(typeCount)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);
                
                blocksList.innerHTML = sortedTypes
                    .map(([type, count]) => {
                        return `<div class="block-type"><span>${type}</span><span>${count}</span></div>`;
                    })
                    .join('');
            } else {
                blocksList.innerHTML = '<div class="block-type">无记忆方块</div>';
            }
        }
        
        // 更新性能统计
        function updatePerformanceStats() {
            const timeSinceUpdate = (Date.now() - renderStats.lastUpdate) / 1000;
            
            renderStats.blocksAdded = 0;
            renderStats.blocksRemoved = 0;
            renderStats.lastUpdate = Date.now();
        }
        
        // 控制函数
        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connection-indicator');
            const text = document.getElementById('connection-text');
            
            if (connected) {
                indicator.classList.add('connected');
                text.textContent = '已连接 - 记忆模式';
            } else {
                indicator.classList.remove('connected');
                text.textContent = '未连接';
            }
        }
        
        function sendMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log('发送消息', message);
                ws.send(JSON.stringify(message));
                return true;
            } else {
                addLog('发送失败: WebSocket未连接');
                return false;
            }
        }
        
        function navigateTo() {
            const x = parseFloat(document.getElementById('nav-x').value);
            const y = parseFloat(document.getElementById('nav-y').value);
            const z = parseFloat(document.getElementById('nav-z').value);
            
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                if (sendMessage({
                    type: 'command',
                    command: 'navigate',
                    target: { x, y, z }
                })) {
                    addLog(`开始导航到 (${x}, ${y}, ${z})`);
                }
            } else {
                addLog('请输入有效的坐标');
            }
        }
        
        function stopNavigation() {
            if (sendMessage({
                type: 'command',
                command: 'stop'
            })) {
                addLog('停止导航');
            }
        }
        
        function getStatus() {
            if (sendMessage({
                type: 'command',
                command: 'status'
            })) {
                addLog('请求状态更新');
            }
        }
        
        function getCurrentPos() {
            if (agentData.position) {
                document.getElementById('nav-x').value = agentData.position.x.toFixed(1);
                document.getElementById('nav-y').value = agentData.position.y.toFixed(1);
                document.getElementById('nav-z').value = agentData.position.z.toFixed(1);
                addLog('当前位置已填入导航框');
            }
        }
        
        function updateViewDistance() {
            const value = document.getElementById('view-distance').value;
            document.getElementById('view-distance-value').textContent = value;
            console.log('setViewDistance', value);
            sendMessage({ type: 'setViewDistance', value: Number(value) });
        }
        
        function toggleGrid() {
            if (gridHelper) {
                gridHelper.visible = document.getElementById('show-grid-3d').checked;
            }
        }
        
        function toggleAgentTrail() {
            if (!document.getElementById('show-agent-trail').checked && trailLine) {
                scene.remove(trailLine);
                trailLine = null;
                agentTrail = [];
            }
        }
        
        function toggleMemoryMode() {
            memoryOnlyMode = document.getElementById('show-memory-only').checked;
            addLog(memoryOnlyMode ? '切换为记忆模式' : '切换为实时模式');
        }
        
        function addLog(message) {
            const logContent = document.getElementById('log-content');
            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `[${time}] ${message}`;
            logContent.appendChild(logEntry);
            logContent.scrollTop = logContent.scrollHeight;
            
            while (logContent.children.length > 15) {
                logContent.removeChild(logContent.firstChild);
            }
        }
        
        function updateCanvasSizes() {
            // 更新3D渲染器大小
            if (renderer) {
                const container = document.getElementById('modeling-view');
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
            
            // 更新2D画布大小
            const canvas = document.getElementById('minimap-canvas');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // 重新绘制2D地图
            draw2DMinimap();
        }
        
        // 视图控制函数
        function refreshViewer() {
            const iframe = document.getElementById('viewer-iframe');
            iframe.src = iframe.src;
            addLog('刷新游戏画面');
        }
        
        function toggleFullscreen(viewType) {
            addLog(`切换${viewType}全屏模式`);
            // 这里可以实现全屏功能
        }
        
        function toggleMapMode() {
            memoryOnlyMode = !memoryOnlyMode;
            document.getElementById('show-memory-only').checked = memoryOnlyMode;
            addLog(`2D地图切换为${memoryOnlyMode ? '记忆' : '实时'}模式`);
            draw2DMinimap();
        }
        
        function resetCamera() {
            if (camera && controls) {
                camera.position.set(20, 20, 20);
                if (agentData.position) {
                    controls.target.set(
                        agentData.position.x,
                        agentData.position.y,
                        agentData.position.z
                    );
                }
                controls.update();
                addLog('重置3D视角');
            }
        }
        
        // 监听地图缩放变化
        document.getElementById('map-scale').addEventListener('input', function() {
            draw2DMinimap();
        });
        
        // 监听网格和轨迹显示设置
        document.getElementById('show-grid-2d').addEventListener('change', draw2DMinimap);
        document.getElementById('show-trail-2d').addEventListener('change', draw2DMinimap);
        
        // 监听滚轮缩放
        document.getElementById('minimap-canvas').addEventListener('wheel', function(e) {
            e.preventDefault();
            const oldScale = minimapScale;
            if (e.deltaY < 0) {
                minimapScale = Math.min(20, minimapScale + 1);
            } else {
                minimapScale = Math.max(1, minimapScale - 1);
            }
            // 缩放时以鼠标为中心调整偏移
            const rect = this.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            minimapOffset.x = (minimapOffset.x - mx) * (minimapScale / oldScale) + mx;
            minimapOffset.y = (minimapOffset.y - my) * (minimapScale / oldScale) + my;
            draw2DMinimap();
        }, { passive: false });

        // 监听鼠标拖动
        const minimapCanvas = document.getElementById('minimap-canvas');
        minimapCanvas.addEventListener('mousedown', function(e) {
            isDraggingMinimap = true;
            dragStart = { x: e.clientX, y: e.clientY };
            dragOrigin = { x: minimapOffset.x, y: minimapOffset.y };
        });
        window.addEventListener('mousemove', function(e) {
            if (isDraggingMinimap) {
                minimapOffset.x = dragOrigin.x + (e.clientX - dragStart.x);
                minimapOffset.y = dragOrigin.y + (e.clientY - dragStart.y);
                draw2DMinimap();
            }
        });
        window.addEventListener('mouseup', function() {
            isDraggingMinimap = false;
        });
        
        // 启动应用
        init();
        
        // 定期请求记忆数据
        setInterval(() => {
            if (isConnected && memoryOnlyMode) {
                sendMessage({ type: 'requestMemory' });
            }
        }, 1000);
        
        // 定期重绘2D地图
        setInterval(() => {
            if (agentData.position) {
                draw2DMinimap();
            }
        }, 100);
    </script>
</body>
</html>
